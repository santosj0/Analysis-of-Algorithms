import random


# Normal Quicksort
def quicksort_algorithm_normal(arr, start, end):
    """
    Quicksort algorithm that can be found in 'Introduction to Algorithms 3rd Edition.' This algorithm has a best case
    of O(nlg(n)) runtime, worst case of O(n^2) runtime, and an average case of O(nlg(n)) runtime. The algorithm returns
    the index generated by partitioning the passed array into an a sub-array that is less than or equal to the pivot
    number, and a sub-array that is greater than the pivot number. This algorithm recursively does this.
    :param arr: Array of all real numbers.
    :param start: Starting index of the array.
    :param end: Final index of the array.
    :return: A sorted array.
    """
    if start < end:
        pivot = partition_normal(arr, start, end)
        quicksort_algorithm_normal(arr, start, pivot-1)
        quicksort_algorithm_normal(arr, pivot+1, end)
    return arr


def partition_normal(arr, start, end):
    """
    The function compares the last element with all of the elements before it and swaps the elements when needed. Left
    side of the pivot are less than or equal to the pivot and the right side of the pivot are greater than the pivot.
    :param arr: Array of all real numbers.
    :param start: Starting index of the array.
    :param end: Final index of the array.
    :return: Pivot index after the array is sorted.
    """
    comparitor = arr[end]
    i = start - 1
    for j in range(start, end+1):
        if arr[j] <= comparitor:
            i += 1
            swap(arr, i, j)
    return i


# Altered Normal Quicksort
def quicksort_algorithm_prime(arr, start, end):
    """
    Three-way quicksort algorithm that was modified to create three partitions instead of two.
    :param arr: Array of all real numbers.
    :param start: Starting index of the array.
    :param end: Final index of the array.
    :return: Sorted array.
    """
    if start < end:
        l_pivot, r_pivot = partition_prime(arr, start, end)
        quicksort_algorithm_prime(arr, start, l_pivot - 1)
        quicksort_algorithm_prime(arr, r_pivot + 1, end)
    return arr


def partition_prime(arr, start, end):
    """
    Generates three partitions: A greater than comparator, equal to comparator, and less than comparator. This function
    sorts the array based on these three partitions.
    :param arr: Array of all real numbers.
    :param start: Starting index of the array.
    :param end: Final index of the array.
    :return: First index of the equal partition and the final index of the equal partition.
    """
    comparator, en, st = arr[end], end, start
    i = st
    while i <= en:
        if arr[i] < comparator:
            swap(arr, st, i)
            st += 1
        elif arr[i] > comparator:
            swap(arr, en, i)
            en -= 1
            i -= 1
        i += 1
    return st, en


# Normal Randomized Quicksort
def randomized_quicksort_normal(arr, start, end):
    """
    Similar to the quicksort algorithm. However, instead of the final index being the comparator, a random index in the
    array is the comparator and placed in the final position.
    :param arr: Array of all real numbers.
    :param start: Starting index of the array.
    :param end: Final index of the array.
    :return: Sorted array.
    """
    if start < end:
        pivot = randomized_partition_normal(arr, start, end)
        randomized_quicksort_normal(arr, start, pivot - 1)
        randomized_quicksort_normal(arr, pivot + 1, end)
    return arr


def randomized_partition_normal(arr, start, end):
    """
    Selects a random index in the array and makes it the pivot by swapping places with the final element in the array.
    :param arr: Array of all real numbers.
    :param start: Starting array index.
    :param end: Final array index.
    :return: Partition function of the array.
    """
    random_pivot = random.randint(start, end)
    swap(arr, end, random_pivot)
    return partition_normal(arr, start, end)


# Altered Randomized Quicksort
def randomized_quicksort_prime(arr, start, end):
    """
    Similar to the randomized quicksort algorithm. However, the three-way quicksort(partition_prime) is used.
    :param arr: Array of all real numbers.
    :param start: Starting index of the array.
    :param end: Final index of the array.
    :return: Sorted array.
    """
    if start < end:
        l_pivot, r_pivot = randomized_partition_prime(arr, start, end)
        randomized_quicksort_prime(arr, start, l_pivot - 1)
        randomized_quicksort_prime(arr, r_pivot + 1, end)
    return arr


def randomized_partition_prime(arr, start, end):
    """
    Selects a random index in the array and makes it the pivot by swapping places with the final element in the array.
    :param arr: Array of all real numbers.
    :param start: Starting array index.
    :param end: Final array index.
    :return: Altered partition function of the array.
    """
    random_pivot = random.randint(start, end)
    swap(arr, end, random_pivot)
    return partition_prime(arr, start, end)


# Utilities
def swap(arr, pos1, pos2):
    arr[pos1], arr[pos2] = arr[pos2], arr[pos1]
    return arr


if __name__ == "__main__":
    # Test Cases
    test_cases = [
        [8, 2, 4, 1, 6, 7, 3, 5, 9],                    # Normal Case
        [-1, -5, -3, -2, -6, -4, -7, -9, -8],           # Negative Case
        [8, 5, 9, 5, 0, 5, 3, 5],                       # Similar Case
        [1, 2, 3, 4, 5, 6, 7, 8, 9]                     # Sorted Case
    ]

    # Answers
    answers = [
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [-9, -8, -7, -6, -5, -4, -3, -2, -1],
        [0, 3, 5, 5, 5, 5, 8, 9],
        [1, 2, 3, 4, 5, 6, 7, 8, 9]
    ]

    # Quicksort Normal Testing
    for test_case, answer in zip(test_cases, answers):
        assert quicksort_algorithm_normal(test_case, 0, len(test_case) - 1) == answer, "Quicksort normal does not " \
                                                                                        "work properly."

    for test_case in test_cases:
        random.shuffle(test_case)

    # Quick Sort Prime Testing
    for test_case, answer in zip(test_cases, answers):
        assert quicksort_algorithm_prime(test_case, 0, len(test_case) - 1) == answer, "Quicksort prime does not " \
                                                                                       "work properly."

    for test_case in test_cases:
        random.shuffle(test_case)

    # Normal Randomized Quicksort Testing
    for test_case, answer in zip(test_cases, answers):
        assert randomized_quicksort_normal(test_case, 0, len(test_case) - 1) == answer, "Randomized quicksort normal " \
                                                                                        "does not work properly."

    for test_case in test_cases:
        random.shuffle(test_case)

    # Altered Randomized Quicksort Testing
    for test_case, answer in zip(test_cases, answers):
        assert randomized_quicksort_prime(test_case, 0, len(test_case) - 1) == answer, "Randomized quicksort prime " \
                                                                                       "does not work properly."

    print("All tests passed.")
